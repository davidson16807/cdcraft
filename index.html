<!doctype html>
<html>
<head>
    <title>Diagram editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="./styles/bootstrap.min.css">
    <script src="./libraries/vue.js"></script>
    <script src="./libraries/glm-js.min.js"></script>
    <style type="text/css">
        svg {
            position: fixed;
            top:0;
            left:0;
            height:100%;
            width:100%;
            user-select: none;
        }
        .cell-border {
            stroke:grey;
            stroke-width:0.5;
            stroke-dasharray: 10,10;
        }
        .arrow {
            fill: none;
            stroke: dimgrey;
            stroke-width:4;
        }
        .arrow-highlight {
            fill: none;
            stroke: darkgrey;
            stroke-opacity: 0.5;
            stroke-width:20;
        }
        .arrow-highlight2 {
            fill: none;
            stroke: blue;
            stroke-opacity: 0.5;
            stroke-width:20;
        }
        .arrow-tip-highlight {
            fill: none;
            stroke: none;
        }
        .arrow-handle {
            fill: red;
            /*fill: lightgrey;*/
            stroke: none;
        }
    </style>
</head>
<body>
<div id="app">
    <svg id="svg">
        <g v-bind:transform="transformation()">
            <g v-for="i in cell_count()">
                <line class="cell-border"
                      v-bind:x1="cell_border_position(i,0).x" v-bind:y1="cell_border_position(0,-cell_count()).y" 
                      v-bind:x2="cell_border_position(i,0).x" v-bind:y2="cell_border_position(0,cell_count()).y"/>
                <line class="cell-border"
                      v-bind:y1="cell_border_position(0,i).y" v-bind:x1="cell_border_position(-cell_count(),0).x" 
                      v-bind:y2="cell_border_position(0,i).y" v-bind:x2="cell_border_position(cell_count(),0).x"/>
            </g>
            <path class="arrow-highlight" v-bind:d="path(state.edited_arrow)" />
            <path class="arrow-highlight2" v-bind:d="path2(state.edited_arrow)" />
            <circle class="arrow-tip-highlight" v-bind:cx="point(state.edited_arrow.start).x" v-bind:cy="point(state.edited_arrow.start).y" r="10"/>
            <circle class="arrow-tip-highlight" v-bind:cx="point(state.edited_arrow.end).x" v-bind:cy="point(state.edited_arrow.end).y" r="10" />
            <!-- <circle class="arrow-handle" v-bind:cx="point(state.edited_arrow.start).x" v-bind:cy="point(state.edited_arrow.start).y" r="10"/> -->
            <!-- <circle class="arrow-handle" v-bind:cx="point(state.edited_arrow.end).x" v-bind:cy="point(state.edited_arrow.end).y" r="10" /> -->
            <circle class="arrow-handle" v-bind:cx="midpath(state.edited_arrow).x" v-bind:cy="midpath(state.edited_arrow).y" r="10" />
            <path class="arrow" v-bind:d="path(state.edited_arrow)"/>
        </g>
    </svg>
</div>

<!-- logo -->
<script type="text/javascript">
    'use strict';


    class Arrow {
        constructor(
            start, end, min_length, is_clockwise, 
            label, label_position_id, 
            start_style_id, end_style_id, line_style_id
        ){
            this.start = start;
            this.end = end;
            this.min_length = min_length || 0.7;
            this.is_clockwise = is_clockwise || false;
            this.label = label || "";
            this.label_position_id = label_position_id;
            this.start_style_id = start_style_id;
            this.end_style_id = end_style_id;
            this.line_style_id = line_style_id;
        }
    }

    /*
    "DiagramReferenceFrame" can be considered a degenerate case of an affine transform.
    It permits scaling and translation but forbids rotation or shearing.
    */
    class DiagramReferenceFrame {
        constructor(origin, scale){
            this.origin = origin;
            this.scale = scale;
        }
    }

    function DiagramIds(){
        const floor = Math.floor;
        const round = Math.round;
        const abs = Math.abs;
        return {
            'cell_position_to_border_id': cell_position => glm.vec2(floor(cell_position.x), floor(cell_position.y)),
            'border_id_to_cell_position': border_id => border_id.add(0.5),
            'cell_position_to_cell_id': cell_position => glm.vec2(round(cell_position.x), round(cell_position.y)),
            'cell_position_and_cell_id_to_offset': (cell_position, cell_id) => cell_position.sub(cell_id),
            'offset_to_basis': offset => glm.sign(offset).mul(glm.vec2(glm.bvec2(abs(offset.x) > abs(offset.y), abs(offset.x) < abs(offset.y)))),
            'offset_to_basis_id': offset => ((offset.x > offset.y) << 1) + (-offset.x > offset.y),
        };
    }

    function DiagramSnapping(diagram_ids, cell_to_target_distance) {
        const ids = diagram_ids;
        return {
            'snap_to_cell': model => ids.cell_position_to_cell_id(model),
            'snap_to_target_handle': function(model){
                return model;
                const cell_id = ids.cell_position_to_cell_id(model);
                return ids.offset_to_basis(ids.cell_position_and_cell_id_to_offset(model, cell_id)).mul(cell_to_target_distance).add(cell_id);
            },
        };
    }

    function PositionFrameShifting(){
        const pow = Math.pow;
        return {
            'view_to_model': (view_position, state) => view_position.div( pow(2.0, state.log2_cell_width) ).add(state.topleft_cell_position),
            'model_to_view': (model_position, state) => model_position.sub(state.topleft_cell_position).mul( pow(2.0, state.log2_cell_width) ),
        };
    }

    function ArrowFrameShifting(vector_frame_shifting){
        const pow = Math.pow;
        const shifting = vector_frame_shifting;
        return {
            'model_to_view': (model_arrow, state) => new Arrow(
                    shifting.model_to_view(model_arrow.start, state),
                    shifting.model_to_view(model_arrow.end, state),
                    model_arrow.min_length * pow(2.0, state.log2_cell_width),
                    model_arrow.is_clockwise,
                    model_arrow.label,
                    model_arrow.label_position_id,
                    model_arrow.start_style_id,
                    model_arrow.end_style_id,
                    model_arrow.line_style_id
                ),
            'view_to_model': (view_arrow, state) => new Arrow(
                    shifting.model_to_view(view_arrow.start, state),
                    shifting.model_to_view(view_arrow.end, state),
                    model_arrow.min_length / pow(2.0, state.log2_cell_width),
                    model_arrow.is_clockwise,
                    model_arrow.label,
                    model_arrow.label_position_id,
                    model_arrow.start_style_id,
                    model_arrow.end_style_id,
                    model_arrow.line_style_id
                ),
        }
    }

    const DragState = {
        released: 'released',
        draw: 'draw',
        zoom: 'zoom',
        pan: 'pan',
    };

    /*
    "ApplicationState" contains all state within the application. 
    It guarantees that for any combination of real numbered attribute values there is a valid application state.
    */
    class ApplicationState {
        constructor(topleft_cell_position, log2_cell_width, drag_state, edited_arrow){
            this.topleft_cell_position = topleft_cell_position;
            this.log2_cell_width = log2_cell_width;
            this.drag_state = drag_state;
            this.edited_arrow = edited_arrow;
        }
    }

    /*
    "ApplicationState" is a namespace of conceptually pure functions that operate with no concept of what hardware is being used.
    All functions represent the transformation of state in reponse to controller events. 
    */
    function DiagramStateOperations(diagram_view_coordinates, diagram_snapping) {
        const pow = Math.pow;
        const spaces = diagram_view_coordinates;
        const snapping = diagram_snapping;
        return {
            zoom: function(state_in, log2_cell_width_change, state_out) {
                state_out.topleft_cell_position = state_in.topleft_cell_position;
                state_out.log2_cell_width = state_in.log2_cell_width + log2_cell_width_change;
                state_out.drag_state = DragState.zoom;
                state_out.edited_arrow = state_in.edited_arrow;
            },
            pan: function(state_in, motion, state_out){
                state_out.topleft_cell_position = state_in.topleft_cell_position.sub(motion.div(pow(2.0, state_in.log2_cell_width)));
                state_out.log2_cell_width = state_in.log2_cell_width;
                state_out.drag_state = DragState.pan;
                state_out.edited_arrow = state_in.edited_arrow;
            },
            draw: function(state_in, view_position, state_out){
                state_out.topleft_cell_position = state_in.topleft_cell_position;
                state_out.log2_cell_width = state_in.log2_cell_width;
                const model_position = spaces.view_to_model(view_position, state_in);
                const source = snapping.snap_to_cell(model_position);
                const target = snapping.snap_to_target_handle(model_position);
                state_out.edited_arrow = state_in.drag_state == DragState.draw
                    ? new Arrow(state_in.edited_arrow.start, target, 
                        state_in.edited_arrow.is_clockwise,
                        state_in.edited_arrow.label,
                        state_in.edited_arrow.label_position_id,
                        state_in.edited_arrow.start_style_id,
                        state_in.edited_arrow.end_style_id,
                        state_in.edited_arrow.line_style_id)
                    : new Arrow(source, target,
                        state_in.edited_arrow.is_clockwise,
                        state_in.edited_arrow.label,
                        state_in.edited_arrow.label_position_id,
                        state_in.edited_arrow.start_style_id,
                        state_in.edited_arrow.end_style_id,
                        state_in.edited_arrow.line_style_id);
                state_out.drag_state = DragState.draw;
            },
            copy: function(state_in, state_out){
                state_out.topleft_cell_position = state_in.topleft_cell_position;
                state_out.log2_cell_width = state_in.log2_cell_width;
                state_out.drag_state = state_in.drag_state;
                state_out.edited_arrow = state_in.edited_arrow;
            }
        };
    }

    /*
    "DiagramControls" is a namespace of conceptually pure functions that reflect how events map to actions.
    All functions represent the transformation of state in reponse to controller events. 
    It resembles an "Updater" within the "Model-View-Updater" pattern (A.K.A. "Elm" architecture)
    */
    function DiagramControls(
        diagram_state_operations, 
        log2_cell_width_change_per_scroll
    ){
        const operations = diagram_state_operations;
        const mouse_actions = {
            'pan':  (state_in, event, state_out) => operations.pan(state_in, glm.vec2(event.movementX, event.movementY), state_out),
            'draw': (state_in, event, state_out) => operations.draw(state_in, glm.vec2(event.clientX, event.clientY), state_out),
        };
        return {
            mousedown: function(state_in, event, state_out){
                const state = [DragState.draw, DragState.pan, DragState.pan][event.button];
                if (state in mouse_actions){
                    mouse_actions[state](state_in, event, state_out); 
                }
            },
            mousemove: function(state_in, event, state_out){
                const state = state_in.drag_state;
                if (state in mouse_actions){
                    mouse_actions[state](state_in, event, state_out); 
                }
            },
            mouseup: function(state_in, event, state_out){
                state_out.drag_state = 'released';
            },
            mousewheel: function(state_in, event, state_out){
                operations.zoom(state_in, log2_cell_width_change_per_scroll * event.wheelDelta, state_out);
            },
            DOMMouseScroll: function(state_in, event, state_out){
                operations.zoom(state_in, -log2_cell_width_change_per_scroll * event.detail, state_out);
            },
            touchstart: function(state_in, event, state_out){

            },
            touchend: function(state_in, event, state_out){

            },
            touchmove: function(state_in, event, state_out){

            }
        }
    }

    /*
    "EventQueueSideEffectWrapper" is a object oriented class that encapsulates all use of the javascript event system.
    This is done so that the rest of the application can be managed statelessly, using pure functions and categories.
    It practices RAII in that it binds events to a `domElement` upon construction and does not let go until dispose() is called.
    Events can be retrieved using `poll()`, which returns a list of all events that occurred on the diagram since the last invocation.
    */
    class EventQueueSideEffectWrapper{
        constructor(domElement){
            let queue = [];
            function enqueue( event ) { 
                queue.push(event);
            };
            function enqueuePrevent( event ) { 
                event.preventDefault(); 
                queue.push(event);
            };
            function enqueuePreventStop( event ) { 
                event.preventDefault(); 
                event.stopPropagation();
                queue.push(event);
            };
            domElement.addEventListener('contextmenu',    enqueuePrevent,     false);
            domElement.addEventListener('mousedown',      enqueuePrevent,     false);
            domElement.addEventListener('mousemove',      enqueuePrevent,     false);
            domElement.addEventListener('mouseup',        enqueue,            false);
            domElement.addEventListener('mousewheel',     enqueue,            false);
            domElement.addEventListener('DOMMouseScroll', enqueue,            false);
            domElement.addEventListener('touchstart',     enqueue,            false);
            domElement.addEventListener('touchmove',      enqueuePreventStop, false);
            domElement.addEventListener('touchend',       enqueue,            false);
            this.dispose = function(){
                domElement.removeEventListener('contextmenu',    enqueuePrevent,     false);
                domElement.removeEventListener('mousedown',      enqueuePrevent,     false);
                domElement.removeEventListener('mousemove',      enqueuePrevent,     false);
                domElement.removeEventListener('mouseup',        enqueue,            false);
                domElement.removeEventListener('mousewheel',     enqueue,            false);
                domElement.removeEventListener('DOMMouseScroll', enqueue,            false);
                domElement.removeEventListener('touchstart',     enqueue,            false);
                domElement.removeEventListener('touchmove',      enqueuePreventStop, false);
                domElement.removeEventListener('touchend',       enqueue,            false);
            }
            this.pollWithSideEffect = function(){
                let events = queue;
                queue = [];
                return events;
            }
        }
    }


    function LineGeometry(){
        const abs = Math.abs;
        return {
            /*
            A0 line reference
            A  line direction, normalized
            B0 line reference
            B  line direction, normalized
            */
            distance_along_line_to_line: function(A0,A, B0,B){
                return glm.cross((B0.sub(A0)), B).z / glm.cross(A, B).z;
            }
        };
    }

    function ArcGeometry(){
        const pi = Math.PI;
        const pow = Math.pow;
        const acos = Math.acos;
        const cos = Math.cos;
        const sin = Math.sin;
        const min = Math.min;
        const max = Math.max;
        const sqrt = Math.sqrt;
        const epsilon = 1e-6;
        return {
            origin: function(start, end, radius, is_clockwise, min_radius){
                const chord = end.sub(start);
                const chord_length = glm.length(chord);
                const chord_direction = glm.normalize(chord);
                const chord_tangent = glm.vec2(chord_direction.y, -chord_direction.x)
                    .mul(chord_length < 2*min_radius? -1:1)
                    .mul(is_clockwise? 1:1);
                const r = radius;
                const x = glm.length(end.sub(start)) / 2.0;
                const y = sqrt(r*r - x*x);
                const chord_midpoint = start.add(end).div(2);
                const origin = chord_tangent.mul(y).add(chord_midpoint);
                return origin;
            },
            position_at_distance_along_arc: function (start, origin, radius, is_clockwise, distance){
                const v = start.sub(origin);
                const theta = -distance / radius;
                return glm.vec2(
                    v.x * cos(theta) - v.y * sin(theta),
                    v.x * sin(theta) + v.y * cos(theta),
                ).add(origin);
            },
            radius_for_chord_and_arc_length: function(start, end, arc_length){
                /*
                NOTE: 
                Given the start position, end position, and length of an arc, we want to find the radius of the circle that is traced by the arc.
                We find the problem reduces to finding the radius ("r") of a semicircle given half the chord length ("x") and half the arc length ("A").
                We draw a right triangle on the semicircle with a hypoteneuse of r, a leg of x opposite to the origin, and angle of θ such that:
                  x/r = sin(θ)
                The angle subtended by the arc ("ϕ") takes up the rest of the semicircle, so if we use radians then:
                  ϕ = π-θ = A/r
                We have a lot of unknowns to work with (r, θ, and ϕ), so we first try to remove some from consideration.
                Using the equations above we find that:
                  x/(A/ϕ) = sin(π-ϕ)
                which simplifies to:
                  x/A = sin(ϕ)/ϕ
                So we can solve the problem by approximating the inverse of sin(ϕ)/ϕ
                We start our approximation by noticing that it resembles 2acos(ϕ) for our range of interest, [0,π]:
                  https://www.desmos.com/calculator/unllvphdq0
                It's slightly off towards the middle of the range, but all we have to do is find an expression for a factor that we can "nudge" it by.
                We model this "nudge" factor as 1-axᵇ, and by fitting the function manually, we get adequate results using a = 0.147 and b = 0.65.
                In summary, our approximation is:
                  ϕ = A/r ≈ 2 (1-a(x/A)ᵇ) acos(x/A)
                And our solution is:
                  r ≈ A / (2 (1-a(x/A)ᵇ) acos(x/A))
                */
                const a = 0.147;
                const b = 0.650;
                const x = glm.length(end.sub(start)) / 2.0;
                const A = max(x, arc_length/2 );
                const xA = min(x/A, 1-epsilon);
                const r = A / (2.0 * (1.0 - a*pow(xA, b)) * acos(xA));
                return r;
            },
        }
    }

    function ArcSvg(arc_geometry, line_geometry){
        const pi = Math.PI;
        const sqrt = Math.sqrt;
        const max = Math.max;
        // A "DiagramArc" is an arc defined in terms that are useful to depict arrows in a diagram.
        // It starts from the premise that an arrow must have a minimum nonzero length for it to be visible to the user.
        class DiagramArc{
            constructor(start, end, length, is_clockwise){
                this.start = start;
                this.end = end;
                this.length = length;
                this.is_clockwise = is_clockwise;
            }
        };
        // An "SvgArc" is an arc as defined by svg paths
        class SvgArc{
            constructor(start, end, radius, is_large_arc, is_clockwise){
                this.start = start;
                this.end = end;
                this.radius = radius;
                this.is_large_arc = is_large_arc;
                this.is_clockwise = is_clockwise;
            }
        };
        // A "SvgQuadraticBezier" is a representation for a quadratic Bezier that can be used by svg
        class SvgQuadraticBezier{
            constructor(points){
                this.points = points;
            }
        };

        return {
            'DiagramArc' : DiagramArc,
            diagram_arc_to_svg_arc: function(arc){
                const radius = arc_geometry.radius_for_chord_and_arc_length(arc.start, arc.end, arc.length);
                return new SvgArc(arc.start, arc.end, 
                    radius, arc.length/radius > pi, arc.is_clockwise);
            },
            diagram_arc_to_svg_bezier: function(arc, sample_point_count){
                const length = max(arc.length, glm.length(arc.end.sub(arc.start)));
                const min_radius = arc.length/pi;
                const radius = arc_geometry.radius_for_chord_and_arc_length(arc.start, arc.end, length);
                const origin = arc_geometry.origin(arc.start, arc.end, radius, arc.is_clockwise, min_radius);
                const sample_points = [];
                for (let i = 0; i <= sample_point_count; i++) {
                    sample_points.push(arc_geometry.position_at_distance_along_arc(arc.start, origin, radius, arc.is_clockwise, length * i/sample_point_count));
                }
                const points = [sample_points[0]];
                for (let i = 1; i <= sample_point_count; i++) {
                    const a = sample_points[i-1].sub(origin);
                    const b = sample_points[i].sub(origin);
                    const k = glm.vec3(0,0,1);
                    const a_tangent = glm.normalize(glm.cross(glm.vec3(a,0), k)).xy;
                    const b_tangent = glm.normalize(glm.cross(glm.vec3(b,0), k)).xy;
                    // console.log(a.x, a.y, a_tangent.x, a_tangent.y, b.x, b.y, b_tangent.x, b_tangent.y);
                    const intersection = a_tangent.mul(line_geometry.distance_along_line_to_line(a,a_tangent,b,b_tangent)).add(a).add(origin);
                    points.push(intersection);
                    points.push(sample_points[i]);
                }
                return new SvgQuadraticBezier(points);
            },
            svg_bezier_to_path: function(bezier){
                const points = bezier.points;
                const start = points[0];
                let output = `M ${start.x} ${start.y}`;
                for (let i = 1; i+1 < points.length; i+=2) {
                    const control = points[i];
                    const sample = points[i+1];
                    output += ` Q ${control.x} ${control.y} ${sample.x} ${sample.y}`;
                }
                return output;
            },
            svg_arc_to_path: function(arc){
                return `M ${arc.start.x} ${arc.start.y} A ${arc.radius} ${arc.radius} 0 ${arc.is_large_arc?1:0} ${arc.is_clockwise?0:1} ${arc.end.x} ${arc.end.y}` ;
            },
        }
    }

    function ArrowSvg(diagram_svg){
        const svg = diagram_svg;
        return {
            'view_to_path': function(view_arrow) {
                const arc = new svg.DiagramArc(
                    view_arrow.start,
                    view_arrow.end,
                    view_arrow.min_length, 
                    true
                );
                const svg_arc = svg.diagram_arc_to_svg_arc(arc);
                const svg_bezier = svg.diagram_arc_to_svg_bezier(arc, 10);
                // const path = svg.svg_arc_to_path(svg_arc);
                const path = svg.svg_bezier_to_path(svg_bezier);
                return path;
            },
        };
    }

    const vue = new Vue({
        el: '#app',
        data:{
            state: new ApplicationState(glm.vec2(), Math.log2(200), DragState.released, new Arrow(glm.vec2(), glm.vec2())),
            queue: undefined,
            controls: DiagramControls(
                DiagramStateOperations(
                    PositionFrameShifting(), 
                    DiagramSnapping(DiagramIds(), 0.1)
                ),
                0.1
            ),
            vector_shifting: PositionFrameShifting(),
            arrow_shifting: ArrowFrameShifting(PositionFrameShifting()),
            ids: DiagramIds(),
        },
        created: function() {
            // Register event manager in setTimeout to prevent vue from inapproprately touching event listeners
            setTimeout(() => {this.queue = new EventQueueSideEffectWrapper(document.getElementById('svg'));}, 1000/60);
            setInterval(() => {
                if (this.queue) {
                    let events = this.queue.pollWithSideEffect();
                    for(event of events){
                        if (event.type in this.controls){
                            this.controls[event.type](this.state, event, this.state);
                        }
                    }
                }
            }, 1000/60);
        },
        methods: {
            transformation: function() {
                const top_left_view_position = this.vector_shifting.model_to_view(this.state.topleft_cell_position, this.state);
                return `translate(${-top_left_view_position.x} ${-top_left_view_position.y})`;
            },
            cell_count: function() {
                return Math.ceil(Math.max(document.documentElement.clientWidth, document.documentElement.clientHeight) / Math.pow(2.0, this.state.log2_cell_width));
            },
            cell_border_position: function(x, y) {
                return this.vector_shifting.model_to_view(
                    this.ids.border_id_to_cell_position( this.ids.cell_position_to_border_id(this.state.topleft_cell_position).add(glm.ivec2(x-1,y-1)) ), 
                    this.state
                );
            },
            path: function(arrow) {
                const svg = ArcSvg(ArcGeometry(), LineGeometry());
                const view_arrow = this.arrow_shifting.model_to_view(arrow, this.state);
                const arc = new svg.DiagramArc(
                    view_arrow.start,
                    view_arrow.end,
                    view_arrow.min_length, 
                    true
                );
                const svg_arc = svg.diagram_arc_to_svg_arc(arc);
                const svg_bezier = svg.diagram_arc_to_svg_bezier(arc, 10);
                const path = svg.svg_arc_to_path(svg_arc);
                // const path = svg.svg_bezier_to_path(svg_bezier);
                return path;
            },
            path2: function(arrow) {
                const svg = ArcSvg(ArcGeometry(), LineGeometry());
                const view_arrow = this.arrow_shifting.model_to_view(arrow, this.state);
                const arc = new svg.DiagramArc(
                    view_arrow.start,
                    view_arrow.end,
                    view_arrow.min_length, 
                    true
                );
                const svg_arc = svg.diagram_arc_to_svg_arc(arc);
                const svg_bezier = svg.diagram_arc_to_svg_bezier(arc, 10);
                // const path = svg.svg_arc_to_path(svg_arc);
                const path = svg.svg_bezier_to_path(svg_bezier);
                return path;
            },
            point: function(coordinate) {
                return this.vector_shifting.model_to_view(coordinate, this.state);
            },
            midpath: function(arrow) {
                const view_arrow = this.arrow_shifting.model_to_view(arrow, this.state);
                const arcs = ArcGeometry();
                const length = Math.max(view_arrow.min_length, glm.length(view_arrow.end.sub(view_arrow.start)));
                const min_radius = view_arrow.min_length/Math.PI;
                const radius = arcs.radius_for_chord_and_arc_length(view_arrow.start, view_arrow.end, length);
                const origin = arcs.origin(view_arrow.start, view_arrow.end, radius, view_arrow.is_clockwise, min_radius);
                const midpath = arcs.position_at_distance_along_arc(view_arrow.start, origin, radius, view_arrow.is_clockwise, 1*length);
                return origin
            },
        }
    });
</script>
</body>
</html>