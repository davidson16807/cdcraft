<!doctype html>
<html>
<head>
    <title>Diagram editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="./styles/bootstrap.min.css">
    <script src="./libraries/vue.js"></script>
    <script src="./libraries/glm-js.min.js"></script>
    <style type="text/css">
        svg {
            position: fixed;
            top:0;
            left:0;
            height:100%;
            width:100%;
            user-select: none;
        }
        .cell-border {
            stroke:grey;
            stroke-width:0.5;
            stroke-dasharray: 10,10;
        }
        .arrow {
            fill: none;
            stroke: dimgrey;
            stroke-width:4;
        }
        .arrow-highlight {
            fill: none;
            stroke: darkgrey;
            stroke-width:30;
        }
        .arrow-tip-highlight {
            fill: darkgrey;
            stroke: none;
        }
        .arrow-handle {
            fill: lightgrey;
            stroke: none;
        }
    </style>
</head>
<body>
<div id="app">
    <svg id="svg">
        <g v-bind:transform="transformation()">
            <g v-for="i in cell_count()">
                <line class="cell-border"
                      v-bind:x1="cell_border_position(i,0).x" v-bind:y1="cell_border_position(0,-cell_count()).y" 
                      v-bind:x2="cell_border_position(i,0).x" v-bind:y2="cell_border_position(0,cell_count()).y"/>
                <line class="cell-border"
                      v-bind:y1="cell_border_position(0,i).y" v-bind:x1="cell_border_position(-cell_count(),0).x" 
                      v-bind:y2="cell_border_position(0,i).y" v-bind:x2="cell_border_position(cell_count(),0).x"/>
            </g>
            <g v-if="is_drawing()">
                <path class="arrow-highlight" v-bind:d="path(state.edited_arrow)" />
                <circle class="arrow-tip-highlight" v-bind:cx="point(state.edited_arrow.start).x" v-bind:cy="point(state.edited_arrow.start).y" r="15"/>
                <circle class="arrow-tip-highlight" v-bind:cx="point(state.edited_arrow.end).x" v-bind:cy="point(state.edited_arrow.end).y" r="15" />
                <circle class="arrow-handle" v-bind:cx="point(state.edited_arrow.start).x" v-bind:cy="point(state.edited_arrow.start).y" r="10"/>
                <circle class="arrow-handle" v-bind:cx="point(state.edited_arrow.end).x" v-bind:cy="point(state.edited_arrow.end).y" r="10" />
                <!-- <circle class="arrow-handle" v-bind:cx="midpath(state.edited_arrow).x" v-bind:cy="midpath(state.edited_arrow).y" r="10" /> -->
                <path class="arrow" v-bind:d="path(state.edited_arrow)"/>
            </g>
        </g>
    </svg>
</div>

<!-- logo -->
<script type="text/javascript">
    'use strict';

    /*
    "Arrow" is a data structure that represents only the attributes within the mathematical definition of an arrow
    */
    class Arrow {
        constructor(start, end){
            this.start = start;
            this.end = end;
        }
    }

    /*
    "DiagramArc" is a data structure that represents a directed arc in a way that can be easily manipulated in the application
    "min_length_clockwise" is the minimum length of an arc, where sign inidicates arc chirality (positive values are clockwise).
    */
    class DiagramArc {
        constructor(start, end, min_length_clockwise){
            this.start = start;
            this.end = end;
            this.min_length_clockwise = min_length_clockwise;
        }
    }

    /*
    "DiagramArrow" is a data structure that represents every property of an arrow that can be depicted within a diagram.
    */
    class DiagramArrow {
        constructor(
            start, end, min_length_clockwise, 
            label, label_position_id, 
            start_style_id, end_style_id, line_style_id
        ){
            this.start = start;
            this.end = end;
            this.min_length_clockwise = min_length_clockwise || 0.7;
            this.label = label || "";
            this.label_position_id = label_position_id;
            this.start_style_id = start_style_id;
            this.end_style_id = end_style_id;
            this.line_style_id = line_style_id;
        }
    }

    /*
    "DiagramReferenceFrame" is a data structure that can be considered a degenerate case of an affine transform.
    It permits scaling and translation but forbids rotation and shearing.
    Its origin and unit length are each stored in terms of another reference frame that the user must define.
    */
    class DiagramReferenceFrame {
        constructor(origin, unit_length){
            this.origin = origin;
            this.unit_length = unit_length;
        }
    }

    /*
    "ViewReferenceFrame" is a data structure that expresses a DiagramReferenceFrame 
    in a way that can be easily manipulated by the application while guaranteeing correctness 
    for all real valued attributes.
    */
    class ViewReferenceFrameStore {
        constructor(topleft_cell_position, log2_cell_width){
            this.topleft_cell_position = topleft_cell_position;
            this.log2_cell_width = log2_cell_width;
        }
    }

    /*
    "ViewReferenceFrameStorage" is a namespace of pure functions that describe the isomorphism 
    between a ViewReferenceFrame and a DiagramReferenceFrame expressed in terms of "model space"
    where each cell is of unit length.
    */
    function ViewReferenceFrameStorage(){
        const pow = Math.pow;
        const log2 = Math.log2;
        return {
            'pack': (frame) => new ViewReferenceFrameStore(frame.topleft_cell_position, log2(1/frame.unit_length)),
            'unpack': (view) => new DiagramReferenceFrame(view.topleft_cell_position, 1/pow(2, view.log2_cell_width)),
        };
    }

    /*
    "PositionFrameShifting" is a namespace of pure functions that describe the isomorphism 
    between points in the "view space" used to specify svg and the "model space" where each cell is of unit length
    */
    function PositionFrameShifting(){
        return {
            'enter': (position, frame) => position.sub(frame.origin).div(frame.unit_length),
            'leave': (position, frame) => position.mul(frame.unit_length).add(frame.origin),
        };
    }

    /*
    "ArcFrameShifting" is a namespace of pure functions that describe the isomorphism 
    between arrows in the "view space" used to specify svg and the "model space" where each cell is of unit length
    */
    function ArcFrameShifting(position_frame_shifting){
        const shifting = position_frame_shifting;
        return {
            'enter': (model_arrow, frame) => 
                new DiagramArc(
                    shifting.enter(model_arrow.start, frame),
                    shifting.enter(model_arrow.end, frame),
                    model_arrow.min_length_clockwise / frame.unit_length,
                ),
            'leave': (view_arrow, frame) =>
                new DiagramArc(
                    shifting.leave(view_arrow.start, frame),
                    shifting.leave(view_arrow.end, frame),
                    model_arrow.min_length_clockwise * frame.unit_length,
                ),
        };
    }

    /*
    "DiagramIds" is a namespace describing a small category of pure functions mapping between position indicators in model space
    */
    function DiagramIds(){
        const floor = Math.floor;
        const round = Math.round;
        const abs = Math.abs;
        return {
            'cell_position_to_border_id': cell_position => glm.vec2(floor(cell_position.x), floor(cell_position.y)),
            'border_id_to_cell_position': border_id => border_id.add(0.5),
            'cell_position_to_cell_id': cell_position => glm.vec2(round(cell_position.x), round(cell_position.y)),
            'cell_position_and_cell_id_to_offset': (cell_position, cell_id) => cell_position.sub(cell_id),
            'offset_to_basis': offset => glm.sign(offset).mul(glm.vec2(glm.bvec2(abs(offset.x) > abs(offset.y), abs(offset.x) < abs(offset.y)))),
            'offset_to_basis_id': offset => ((offset.x > offset.y) << 1) + (-offset.x > offset.y),
        };
    }

    /*
    "PointSnapping" is a namespace of pure functions that describe equivalence classes of user specified positions
    */
    function PointSnapping(diagram_ids, cell_to_target_distance) {
        const ids = diagram_ids;
        return {
            /* 
            A "cell" here is shorthand for the center position of a cell.
            */
            'snap_to_cell': model => ids.cell_position_to_cell_id(model),
            /* 
            A "handle" is any position within a cell that can be used as a target. 
            This includes positions that are off of center to allow the user to specify how loops are oriented.
            */
            'snap_to_handle': function(model){
                const cell_id = ids.cell_position_to_cell_id(model);
                return ids.offset_to_basis(ids.cell_position_and_cell_id_to_offset(model, cell_id)).mul(cell_to_target_distance).add(cell_id);
            },
        };
    }

    /*
    "ArrowSnapping" is a namespace of pure functions that describe equivalence classes of arrows for user specified start and stop positions
    */
    function ArrowSnapping(
        point_snapping, 
        min_loop_chord_length, 
        max_loop_chord_length, 
        max_loop_snap_distance, 
        max_nonloop_snap_distance
    ) {
        const snapping = point_snapping;
        return {
            'snap': function(source_proposal, target_proposal) {
                const source_cell = snapping.snap_to_cell(source_proposal);
                const target_cell = snapping.snap_to_cell(target_proposal);
                const target_handle = snapping.snap_to_handle(target_proposal);

                const is_loop = glm.distance(source_cell, target_cell) < max_loop_chord_length;
                const is_snapped = glm.distance(target_proposal, target_cell) < (is_loop? max_loop_snap_distance : max_nonloop_snap_distance);
                const is_canceled = glm.distance(target_proposal, source_cell) < min_loop_chord_length;

                const source = source_cell;
                const target = 
                      is_canceled?  source_cell
                    : is_snapped?  (is_loop? target_handle : target_cell)
                    :               target_proposal;

                return new Arrow(source, target);
            }
        };
    }

    const DragState = {
        released: 'released',
        draw: 'draw',
        zoom: 'zoom',
        pan: 'pan',
    };

    /*
    "ApplicationState" is a data structure that contains all state within the application. 
    It guarantees that for any combination of real numbered attribute values there is a valid application state.
    */
    class ApplicationState {
        constructor(view_frame_store, drag_state, edited_arrow){
            this.view_frame_store = view_frame_store;
            this.drag_state = drag_state;
            this.edited_arrow = edited_arrow;
        }
    }

    /*
    "DiagramStateOperations" is a namespace of *conceptually* pure functions 
    that operate with no concept of what hardware is being used (e.g. mouse, touchscreen, etc.).
    All functions represent the transformation of state in reponse to controller events. 
    */
    function DiagramStateOperations(view_frame_storage, diagram_view_coordinates, arrow_snapping) {
        const pow = Math.pow;
        const storage = view_frame_storage;
        const spaces = diagram_view_coordinates;
        const snapping = arrow_snapping;
        return {
            zoom: function(state_in, focus, log2_cell_width_change, state_out) {
                console.log(state_out);
                // let topleft_cell_position = state_in.view_frame_store.topleft_cell_position.sub(focus);
                state_out.view_frame_store.topleft_cell_position = state_in.view_frame_store.topleft_cell_position;
                state_out.view_frame_store.log2_cell_width = state_in.view_frame_store.log2_cell_width + log2_cell_width_change;
                state_out.drag_state = DragState.zoom;
                state_out.edited_arrow = state_in.edited_arrow;
            },
            pan: function(state_in, motion, state_out){
                state_out.view_frame_store.topleft_cell_position = state_in.view_frame_store.topleft_cell_position.sub(motion.div(pow(2.0, state_in.view_frame_store.log2_cell_width)));
                state_out.view_frame_store.log2_cell_width = state_in.view_frame_store.log2_cell_width;
                state_out.drag_state = DragState.pan;
                state_out.edited_arrow = state_in.edited_arrow;
            },
            draw: function(state_in, view_position, state_out){
                const view_frame = storage.unpack(state_in.view_frame_store);
                const model_position = spaces.leave(view_position, view_frame);

                let arrow = snapping.snap(
                    state_out.drag_state == DragState.draw? state_in.edited_arrow.start : model_position,
                    model_position
                );
                let diagram_arrow = new DiagramArrow(
                    arrow.start, arrow.end,
                    state_in.edited_arrow.min_length_clockwise,
                    state_in.edited_arrow.label,
                    state_in.edited_arrow.label_position_id,
                    state_in.edited_arrow.start_style_id,
                    state_in.edited_arrow.end_style_id,
                    state_in.edited_arrow.line_style_id,
                );

                state_out.view_frame_store = state_in.view_frame_store;
                state_out.drag_state = DragState.draw;
                state_out.edited_arrow = diagram_arrow;
            },
            copy: function(state_in, state_out){
                state_out.view_frame_store = state_in.view_frame_store;
                state_out.drag_state = state_in.drag_state;
                state_out.edited_arrow = state_in.edited_arrow;
            }
        };
    }

    /*
    "DiagramControls" is a namespace of *conceptually* pure functions that reflect how events map to actions.
    All functions represent the transformation of state in reponse to controller events. 
    It resembles an "Updater" within the "Model-View-Updater" pattern (A.K.A. "Elm" architecture)
    */
    function DiagramControls(
        diagram_state_operations, 
        log2_cell_width_change_per_scroll,
        min_length_change_per_scroll
    ){
        const sign = Math.sign;
        const abs = Math.abs;
        const max = Math.max;
        const operations = diagram_state_operations;
        const mouse_actions = {
            'pan':  (state_in, event, state_out) => operations.pan(state_in, glm.vec2(event.movementX, event.movementY), state_out),
            'draw': (state_in, event, state_out) => operations.draw(state_in, glm.vec2(event.clientX, event.clientY), state_out),
        };
        return {
            wheel: function(state_in, event, state_out){
                if (state_in.drag_state == DragState.draw) {
                    const chord_length = glm.distance(state_in.edited_arrow.start, state_in.edited_arrow.end);
                    const arc_length1 = 0.7;
                    const arc_length2 = max(arc_length1, chord_length);
                    const min_arc_length = abs(state_in.edited_arrow.min_length_clockwise);
                    const clockwise_sign = sign(state_in.edited_arrow.min_length_clockwise);
                    const excess_in = clockwise_sign * max(min_arc_length - arc_length2, 0);
                    const excess_out = excess_in + min_length_change_per_scroll * event.deltaY;
                    const is_different_sign = sign(excess_in) * sign(excess_out) < 0;
                    const min_length_clockwise_out = sign(excess_out) * (is_different_sign? arc_length1 : (abs(excess_out) + abs(arc_length2)));
                    operations.copy(state_in, state_out);
                    state_out.edited_arrow.min_length_clockwise = min_length_clockwise_out;
                } else {
                    operations.zoom(state_in, glm.vec2(), log2_cell_width_change_per_scroll * event.deltaY, state_out);
                }
            },
            mousedown: function(state_in, event, state_out){
                const state = [DragState.draw, DragState.pan, DragState.pan][event.button];
                if (state_in.drag_state == DragState.draw) { 
                    // cancel draw action
                    state_out.drag_state = DragState.released;
                } else if (state in mouse_actions){
                    mouse_actions[state](state_in, event, state_out); 
                }
                
            },
            mousemove: function(state_in, event, state_out){
                const state = state_in.drag_state;
                if (state in mouse_actions){
                    mouse_actions[state](state_in, event, state_out); 
                }
            },
            mouseup: function(state_in, event, state_out){
                state_out.drag_state = DragState.released;
            },
            touchstart: function(state_in, event, state_out){

            },
            touchend: function(state_in, event, state_out){

            },
            touchmove: function(state_in, event, state_out){

            }
        }
    }

    /*
    "EventQueueSideEffectWrapper" is a object oriented class that encapsulates all use of the javascript event system.
    This is done so that the rest of the application can be managed statelessly, using pure functions and categories.
    It practices RAII in that it binds events to a `domElement` upon construction and does not let go until dispose() is called.
    Events can be retrieved using `pollWithSideEffect()`, which returns a list of all events that occurred on 
    the diagram since the last invocation.
    */
    class EventQueueSideEffectWrapper{
        constructor(domElement){
            let queue = [];
            function enqueue( event ) { 
                queue.push(event);
            };
            function enqueuePrevent( event ) { 
                event.preventDefault(); 
                queue.push(event);
            };
            function enqueuePreventStop( event ) { 
                event.preventDefault(); 
                event.stopPropagation();
                queue.push(event);
            };
            domElement.addEventListener('contextmenu',    enqueuePrevent,     false);
            domElement.addEventListener('mousedown',      enqueuePrevent,     false);
            domElement.addEventListener('mousemove',      enqueuePrevent,     false);
            domElement.addEventListener('mouseup',        enqueue,            false);
            domElement.addEventListener('wheel',          enqueue,            false);
            domElement.addEventListener('touchstart',     enqueue,            false);
            domElement.addEventListener('touchmove',      enqueuePreventStop, false);
            domElement.addEventListener('touchend',       enqueue,            false);
            this.dispose = function(){
                domElement.removeEventListener('contextmenu',    enqueuePrevent,     false);
                domElement.removeEventListener('mousedown',      enqueuePrevent,     false);
                domElement.removeEventListener('mousemove',      enqueuePrevent,     false);
                domElement.removeEventListener('mouseup',        enqueue,            false);
                domElement.removeEventListener('wheel',          enqueue,            false);
                domElement.removeEventListener('touchstart',     enqueue,            false);
                domElement.removeEventListener('touchmove',      enqueuePreventStop, false);
                domElement.removeEventListener('touchend',       enqueue,            false);
            }
            this.pollWithSideEffect = function(){
                let events = queue;
                queue = [];
                return events;
            }
        }
    }


    /*
    "LineGeometry" is intended as a namespace of pure functions describing useful analytic geometry of 2d lines
    */
    function LineGeometry(){
        const abs = Math.abs;
        return {
            /*
            A0 line reference
            A  line direction, normalized
            B0 line reference
            B  line direction, normalized
            */
            distance_along_line_to_line: function(A0,A, B0,B){
                return glm.cross((B0.sub(A0)), B).z / glm.cross(A, B).z;
            }
        };
    }

    /*
    "ArcGeometry" is intended as a namespace of pure functions describing useful analytic geometry of arcs
    */
    function ArcGeometry(){
        const pi = Math.PI;
        const pow = Math.pow;
        const acos = Math.acos;
        const cos = Math.cos;
        const sin = Math.sin;
        const min = Math.min;
        const max = Math.max;
        const sqrt = Math.sqrt;
        const sign = Math.sign;
        const abs = Math.abs;
        const epsilon = 1e-6;
        return {
            origin: function(start, end, min_length_clockwise, radius){
                const chord = end.sub(start);
                const chord_length = glm.length(chord);
                const chord_direction = glm.normalize(chord);
                const min_radius = abs(min_length_clockwise) / pi;
                const v = chord_direction.mul(radius);
                const theta = acos(chord_length/(2*radius)) * (chord_length < 2*min_radius? 1:-1) * -sign(min_length_clockwise);
                return glm.vec2(
                    v.x * cos(theta) - v.y * sin(theta),
                    v.x * sin(theta) + v.y * cos(theta),
                ).add(start);
            },
            position_at_distance_along_arc: function (start, origin, min_length_clockwise, radius, distance){
                const v = start.sub(origin);
                const theta = -distance / radius * -sign(min_length_clockwise);
                return glm.vec2(
                    v.x * cos(theta) - v.y * sin(theta),
                    v.x * sin(theta) + v.y * cos(theta),
                ).add(origin);
            },
            radius_for_chord_and_arc_length: function(start, end, min_length_clockwise){
                /*
                NOTE: 
                Given the start position, end position, and length of an arc, we want to find the radius of the circle that is traced by the arc.
                We find the problem reduces to finding the radius ("r") of a semicircle given half the chord length ("x") and half the arc length ("A").
                We draw a right triangle on the semicircle with a hypoteneuse of r, a leg of x opposite to the origin, and angle of θ such that:
                  x/r = sin(θ)
                The angle subtended by the arc ("ϕ") takes up the rest of the semicircle, so if we use radians then:
                  ϕ = π-θ = A/r
                We have a lot of unknowns to work with (r, θ, and ϕ), so we first try to remove some from consideration.
                Using the equations above we find that:
                  x/(A/ϕ) = sin(π-ϕ)
                which simplifies to:
                  x/A = sin(ϕ)/ϕ
                So we can solve the problem by approximating the inverse of sin(ϕ)/ϕ
                We start our approximation by noticing that it resembles 2acos(ϕ) for our range of interest, [0,π]:
                  https://www.desmos.com/calculator/unllvphdq0
                It's slightly off towards the middle of the range, but all we have to do is find an expression for a factor that we can "nudge" it by.
                We model this "nudge" factor as 1-axᵇ, and by fitting the function manually, we get adequate results using a = 0.147 and b = 0.65.
                In summary, our approximation is:
                  ϕ = A/r ≈ 2 (1-a(x/A)ᵇ) acos(x/A)
                And our solution is:
                  r ≈ A / (2 (1-a(x/A)ᵇ) acos(x/A))
                */
                const arc_length = abs(min_length_clockwise);
                const a = 0.147;
                const b = 0.650;
                const x = glm.distance(start, end) / 2.0;
                const A = max(x, arc_length/2 );
                const xA = min(x/A, 1-epsilon);
                const r = A / (2.0 * (1.0 - a*pow(xA, b)) * acos(xA));
                return r;
            },
        }
    }

    /*
    "ArcSvg" is a namespace of pure functions describing a small category mapping arcs to svg depictions
    */
    function ArcSvg(arc_geometry, line_geometry){
        const pi = Math.PI;
        const sqrt = Math.sqrt;
        const max = Math.max;
        const abs = Math.abs;
        // An "SvgArc" is an arc as defined by svg paths
        class SvgArc{
            constructor(start, end, radius, is_large_arc, is_clockwise){
                this.start = start;
                this.end = end;
                this.radius = radius;
                this.is_large_arc = is_large_arc;
                this.is_clockwise = is_clockwise;
            }
        };
        // A "SvgQuadraticBezier" is a representation for a quadratic Bezier that can be used by svg
        class SvgQuadraticBezier{
            constructor(points){
                this.points = points;
            }
        };

        return {
            diagram_arc_to_svg_arc: function(arc){
                const min_length = abs(arc.min_length_clockwise);
                const length = max(min_length, glm.distance(arc.start, arc.end));
                const radius = arc_geometry.radius_for_chord_and_arc_length(arc.start, arc.end, arc.min_length_clockwise);
                return new SvgArc(arc.start, arc.end, 
                    radius, abs(arc.min_length_clockwise)/radius > pi, !arc.is_clockwise);
            },
            diagram_arc_to_svg_bezier: function(arc, sample_point_count){
                const min_length = abs(arc.min_length_clockwise);
                const length = max(min_length, glm.distance(arc.start, arc.end));
                const radius = arc_geometry.radius_for_chord_and_arc_length(arc.start, arc.end, arc.min_length_clockwise);
                const origin = arc_geometry.origin(arc.start, arc.end, arc.min_length_clockwise, radius);
                const sample_points = [];
                for (let i = 0; i <= sample_point_count; i++) {
                    sample_points.push(arc_geometry.position_at_distance_along_arc(arc.start, origin, arc.min_length_clockwise, radius, length * i/sample_point_count));
                }
                const points = [sample_points[0]];
                for (let i = 1; i <= sample_point_count; i++) {
                    const a = sample_points[i-1].sub(origin);
                    const b = sample_points[i].sub(origin);
                    const k = glm.vec3(0,0,1);
                    const a_tangent = glm.normalize(glm.cross(glm.vec3(a,0), k)).xy;
                    const b_tangent = glm.normalize(glm.cross(glm.vec3(b,0), k)).xy;
                    const intersection = a_tangent.mul(line_geometry.distance_along_line_to_line(a,a_tangent,b,b_tangent)).add(a).add(origin);
                    points.push(intersection);
                    points.push(sample_points[i]);
                }
                return new SvgQuadraticBezier(points);
            },
            svg_bezier_to_path: function(bezier){
                const points = bezier.points;
                const start = points[0];
                let output = `M ${start.x} ${start.y}`;
                for (let i = 1; i+1 < points.length; i+=2) {
                    const control = points[i];
                    const sample = points[i+1];
                    output += ` Q ${control.x} ${control.y} ${sample.x} ${sample.y}`;
                }
                return output;
            },
            svg_arc_to_path: function(arc){
                return `M ${arc.start.x} ${arc.start.y} A ${arc.radius} ${arc.radius} 0 ${arc.is_large_arc?1:0} ${arc.is_clockwise?0:1} ${arc.end.x} ${arc.end.y}` ;
            },
        }
    }

    const vue = new Vue({
        el: '#app',
        data:{
            state: 
                new ApplicationState(
                    new ViewReferenceFrameStore(glm.vec2(), Math.log2(200)), 
                    DragState.released, 
                    new DiagramArrow(glm.vec2(), glm.vec2()),
                ),
            queue: undefined,
            controls: 
                DiagramControls(
                    DiagramStateOperations(
                        ViewReferenceFrameStorage(),
                        PositionFrameShifting(), 
                        ArrowSnapping(
                            PointSnapping(DiagramIds(), 0.03), // handle separation
                            0.07, 0.5, 0.25, 0.3 // min loop, max loop, loop snap, nonloop snap
                        ) 
                    ),
                    -0.001, // log2_cell_width_change_per_scroll
                    0.001 // min_length_change_per_scroll
                ),
            view_frame_storage: ViewReferenceFrameStorage(), 
            vector_shifting: PositionFrameShifting(),
            arrow_shifting: ArcFrameShifting(PositionFrameShifting()),
            ids: DiagramIds(),
        },
        created: function() {
            // Register event manager in setTimeout to prevent vue from inapproprately touching event listeners
            setTimeout(() => {this.queue = new EventQueueSideEffectWrapper(document.getElementById('svg'));}, 1000/60);
            setInterval(() => {
                if (this.queue) {
                    let events = this.queue.pollWithSideEffect();
                    for(event of events){
                        if (event.type in this.controls){
                            this.controls[event.type](this.state, event, this.state);
                        }
                    }
                }
            }, 1000/60);
        },
        methods: {
            is_drawing: function(){
                return this.state.drag_state == DragState.draw;
            },
            transformation: function() {
                const view_frame = this.view_frame_storage.unpack(this.state.view_frame_store);
                return `translate(${-view_frame.origin.x} ${-view_frame.origin.y})`;
            },
            cell_count: function() {
                return Math.ceil(Math.max(document.documentElement.clientWidth, document.documentElement.clientHeight) / Math.pow(2.0, this.state.view_frame_store.log2_cell_width));
            },
            cell_border_position: function(x, y) {
                const view_frame = this.view_frame_storage.unpack(this.state.view_frame_store);
                const model_border_position = this.ids.border_id_to_cell_position( this.ids.cell_position_to_border_id(view_frame.origin).add(glm.ivec2(x-1,y-1)) );
                return this.vector_shifting.enter(model_border_position, view_frame);
            },
            path: function(arrow) {
                const svg = ArcSvg(ArcGeometry(), LineGeometry());
                const view_frame = this.view_frame_storage.unpack(this.state.view_frame_store);
                const view_arc = this.arrow_shifting.enter(arrow, view_frame);
                const svg_arc = svg.diagram_arc_to_svg_arc(view_arc);
                const svg_bezier = svg.diagram_arc_to_svg_bezier(view_arc, 10);
                // const path = svg.svg_arc_to_path(svg_arc);
                const path = svg.svg_bezier_to_path(svg_bezier);
                return path;
            },
            point: function(coordinate) {
                const view_frame = this.view_frame_storage.unpack(this.state.view_frame_store);
                return this.vector_shifting.enter(coordinate, view_frame);
            },
            midpath: function(arrow) {
                const view_frame = this.view_frame_storage.unpack(this.state.view_frame_store);
                const view_arc = this.arrow_shifting.enter(arrow, view_frame);
                const arcs = ArcGeometry();
                const min_length = abs(arc.min_length_clockwise);
                const length = Math.max(min_length, glm.distance(view_arc.start, view_arc.end));
                const radius = arcs.radius_for_chord_and_arc_length(view_arc.start, view_arc.end, arc.min_length_clockwise);
                const origin = arcs.origin(view_arc.start, view_arc.end, view_arc.min_length_clockwise, radius);
                const midpath = arcs.position_at_distance_along_arc(view_arc.start, origin, view_arc.min_length_clockwise, radius, 1*length);
                return midpath;
            },
        }
    });
</script>
</body>
</html>