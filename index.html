<!doctype html>
<html>
<head>
    <title>Diagram editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="./styles/bootstrap.min.css">
    <script src="./libraries/vue.js"></script>
    <script src="./libraries/glm-js.min.js"></script>
    <style type="text/css">
        svg {
            position: fixed;
            top:0;
            left:0;
            height:100%;
            width:100%;
            user-select: none;
        }
        .cell-border {
            stroke:grey;
            stroke-width:0.5;
            stroke-dasharray: 10,10;
        }
        .arrow {
            fill: none;
            stroke-width:2;
            stroke: black;
            pointer-events: all;
        }
        .arrow-highlight {
            fill: none;
            stroke: darkgrey;
            stroke-width:30;
            pointer-events: all;
        }
        .arrow-tip-highlight {
            fill: darkgrey;
            stroke: none;
            pointer-events: all;
        }
        .arrow-handle {
            fill: grey;
            stroke: none;
            pointer-events: all;
        }
        .arrow-handle:hover {
            fill: lightgrey;
            stroke: none;
            pointer-events: all;
        }
        
        .arrow-group {
            visibility: hidden;
        }
        .arrow-group:hover {
            visibility: visible;
        }
        .arrow-group .arrow {
            visibility: visible;
        }
    </style>
</head>
<body>
<div id="app">
    <svg id="svg">
        <g v-bind:transform="transformation()">
            <g v-for="i in cell_count()">
                <line class="cell-border"
                      v-bind:x1="cell_border_position(i,0).x" v-bind:y1="cell_border_position(0,-cell_count()).y" 
                      v-bind:x2="cell_border_position(i,0).x" v-bind:y2="cell_border_position(0,cell_count()).y"/>
                <line class="cell-border"
                      v-bind:y1="cell_border_position(0,i).y" v-bind:x1="cell_border_position(-cell_count(),0).x" 
                      v-bind:y2="cell_border_position(0,i).y" v-bind:x2="cell_border_position(cell_count(),0).x"/>
            </g>
            <g v-for="arrow in state.arrows" class="arrow-group" v-on:mousedown="arrowclick(arrow, $event)">
                <path class="arrow-highlight" v-bind:d="arrowpath(arrow.arc)" />
                <circle class="arrow-tip-highlight" v-bind:cx="arrowsample(arrow.arc, 0).x" v-bind:cy="arrowsample(arrow.arc, 0).y" r="15"/>
                <circle class="arrow-tip-highlight" v-bind:cx="arrowsample(arrow.arc, 1).x" v-bind:cy="arrowsample(arrow.arc, 1).y" r="15"/>
                <!-- <circle class="arrow-handle" v-bind:cx="arrowsample(arrow.arc, 0).x" v-bind:cy="arrowsample(arrow.arc, 0).y" r="13"/> -->
                <!-- <circle class="arrow-handle" v-bind:cx="arrowsample(arrow.arc, 1).x" v-bind:cy="arrowsample(arrow.arc, 1).y" r="13" /> -->
                <path class="arrow" v-bind:d="arrowhead(arrow.arc)" />
                <path class="arrow" v-bind:d="arrowpath(arrow.arc)"/>
            </g>
            <g v-if="is_drawing()">
                <path class="arrow-highlight" v-bind:d="arrowpath(state.edited_arrow.arc)" />
                <circle class="arrow-tip-highlight" v-bind:cx="arrowsample(state.edited_arrow.arc, 0).x" v-bind:cy="arrowsample(state.edited_arrow.arc, 0).y" r="15"/>
                <circle class="arrow-tip-highlight" v-bind:cx="arrowsample(state.edited_arrow.arc, 1).x" v-bind:cy="arrowsample(state.edited_arrow.arc, 1).y" r="15" />
                <!-- <circle class="arrow-handle" v-bind:cx="arrowsample(state.edited_arrow.arc, 0).x" v-bind:cy="arrowsample(state.edited_arrow.arc, 0).y" r="13"/> -->
                <!-- <circle class="arrow-handle" v-bind:cx="arrowsample(state.edited_arrow.arc, 1).x" v-bind:cy="arrowsample(state.edited_arrow.arc, 1).y" r="13" /> -->
                <path class="arrow" v-bind:d="arrowhead(state.edited_arrow.arc)" />
                <path class="arrow" v-bind:d="arrowpath(state.edited_arrow.arc)"/>
            </g>
        </g>
    </svg>
</div>

<!-- logo -->
<script type="text/javascript">
    'use strict';



    /*
    `DiagramReferenceFrame` is a data structure that can be considered a degenerate case of an affine transform.
    It permits scaling and translation but forbids rotation and shearing.
    Its origin and unit length are each stored in terms of another reference frame that the user must define.
    */
    class DiagramReferenceFrame {
        constructor(origin, unit_length){
            this.origin = origin;
            this.unit_length = unit_length;
        }
    }

    /*
    `OffsetFrameShifting` is a namespace of pure functions that describe an isomorphism.
    `enter` accepts a offset and reference frame, both expressed in terms of an implicit user defined reference frame,
    and returns a offset that is defined in terms of the reference frame. `leave` is inverse to `enter`.
    */
    function OffsetFrameShifting(){
        return {
            'enter': (position, frame) => position.div(frame.unit_length),
            'leave': (position, frame) => position.mul(frame.unit_length),
        };
    }

    /*
    `PositionFrameShifting` is a namespace of pure functions that describe an isomorphism.
    `enter` accepts a position and reference frame, both expressed in terms of an implicit user defined reference frame,
    and returns a position that is defined in terms of the reference frame. `leave` is inverse to `enter`.
    */
    function PositionFrameShifting(){
        return {
            'enter': (position, frame) => position.sub(frame.origin).div(frame.unit_length),
            'leave': (position, frame) => position.mul(frame.unit_length).add(frame.origin),
        };
    }
    
    /*
    `DiagramIds` is a namespace describing a small category of pure functions mapping between position indicators in model space
    */
    function DiagramIds(){
        const floor = Math.floor;
        const round = Math.round;
        const abs = Math.abs;
        return {
            'cell_position_to_border_id': cell_position => glm.vec2(floor(cell_position.x), floor(cell_position.y)),
            'border_id_to_cell_position': border_id => border_id.add(0.5),
            'cell_position_to_cell_id': cell_position => glm.vec2(round(cell_position.x), round(cell_position.y)),
            'cell_position_and_cell_id_to_offset': (cell_position, cell_id) => cell_position.sub(cell_id),
            'offset_to_offset_id': offset => glm.sign(offset).mul(glm.vec2(glm.bvec2(abs(offset.x) > abs(offset.y), abs(offset.x) < abs(offset.y)))),
            'offset_id_to_offset_hash': offset_id => ((offset_id.x > offset_id.y) << 1) + (-offset_id.x > offset_id.y),
            'offset_hash_to_offset_id': offset_hash => glm.normalize(glm.vec2(1,-1).mul(2*floor(offset_hash / 2)-1).add(glm.vec2(-1,-1).mul(2*(offset_hash % 2)-1))),
        };
    }

    /*
    `Arrow` is a data structure that represents only the attributes within the mathematical definition of an arrow
    `source` and `target` are ivec2s indicating source and target in cell coordinates.
    */
    class Arrow {
        constructor(source, target){
            this.source = source;
            this.target = target;
        }
    }


    /*
    `SvgArc` is a data structure that represents a directed arc using the same method as an svg path
    */
    class SvgArc{
        constructor(source, target, radius, is_large_arc, is_clockwise){
            this.source = source;
            this.target = target;
            this.radius = radius;
            this.is_large_arc = is_large_arc;
            this.is_clockwise = is_clockwise;
        }
    };

    /*
    `SamplerArc` is a data structure that represents a directed arc in a way that allows finding properties along the arc for use in rendering.
    */
    class SamplerArc {
        constructor(origin, source_offset, length_clockwise){
            this.origin = origin;
            this.source_offset = source_offset;
            this.length_clockwise = length_clockwise;
        }
    }

    /*
    `UserArc` is a data structure that represents a directed arc in a way that can be easily manipulated by user input.
    `source` and `target` are vec2 indicating source and target in either cell or screen coordinates.
    `min_length_clockwise` is the minimum length of an arc, where sign inidicates arc chirality (positive values are clockwise).
    */
    class UserArc {
        constructor(source, target, min_length_clockwise){
            this.source = source;
            this.target = target;
            this.min_length_clockwise = min_length_clockwise;
        }
    }

    /*
    `StoredArc` is a data structure that represents a directed arc in a way that allows easy storage and manipulation by the application.
    `source` and `target` are vec2s indicating source and target in cell coordinates. Their components are integers if `is_snapped == true`.
    `min_length_clockwise` is the minimum length of an arc, where sign inidicates arc chirality (positive values are clockwise).
    `target_offset_id` is an ivec2 that represents the direction of an offset applied to the target position to indicate the direction of loops.
    `is_snapped` is a boolean indicating whether the arc has been associated with a definite source and target cell and should be included in the diagram.
    */
    class StoredArc {
        constructor(source, target, min_length_clockwise, target_offset_id, is_snapped){
            this.source = source;
            this.target = target;
            this.min_length_clockwise = min_length_clockwise;
            this.target_offset_id = target_offset_id;
            this.is_snapped = is_snapped;
        }
    }

    /*
    `ArcGeometry` is a namespace of pure functions describing useful analytic geometry of arcs
    */
    function ArcGeometry(){
        const pi = Math.PI;
        const pow = Math.pow;
        const acos = Math.acos;
        const cos = Math.cos;
        const sin = Math.sin;
        const min = Math.min;
        const max = Math.max;
        const sign = Math.sign;
        const abs = Math.abs;
        const epsilon = 1e-6;
        return {
            origin: function(source, target, min_length_clockwise, radius){
                const chord = target.sub(source);
                const chord_length = glm.length(chord);
                const chord_direction = glm.normalize(chord);
                const min_radius = abs(min_length_clockwise) / pi;
                const v = chord_direction.mul(radius);
                const theta = acos(chord_length/(2*radius)) * (chord_length < 2*min_radius? 1:-1) * -sign(min_length_clockwise);
                return glm.vec2(
                    v.x * cos(theta) - v.y * sin(theta),
                    v.x * sin(theta) + v.y * cos(theta),
                ).add(source);
            },
            radius: function(source, target, min_length_clockwise){
                /*
                NOTE: 
                Given the source position, target position, and length of an arc, we want to find the radius of the circle that is traced by the arc.
                We find the problem reduces to finding the radius ("r") of a semicircle given half the chord length ("x") and half the arc length ("A").
                We draw a right triangle on the semicircle with a hypoteneuse of r, a leg of x opposite to the origin, and angle of θ such that:
                  x/r = sin(θ)
                The angle subtended by the arc ("ϕ") takes up the rest of the semicircle, so if we use radians then:
                  ϕ = π-θ = A/r
                We have a lot of unknowns to work with (r, θ, and ϕ), so we first try to remove some from consideration.
                Using the equations above we find that:
                  x/(A/ϕ) = sin(π-ϕ)
                which simplifies to:
                  x/A = sin(ϕ)/ϕ
                So we can solve the problem by approximating the inverse of sin(ϕ)/ϕ
                We source our approximation by noticing that it resembles 2acos(ϕ) for our range of interest, [0,π]:
                  https://www.desmos.com/calculator/unllvphdq0
                It's slightly off towards the middle of the range, but all we have to do is find an expression for a factor that we can "nudge" it by.
                We model this "nudge" factor as 1-axᵇ, and by fitting the function manually, we get adequate results using a = 0.147 and b = 0.65.
                In summary, our approximation is:
                  ϕ = A/r ≈ 2 (1-a(x/A)ᵇ) acos(x/A)
                And our solution is:
                  r ≈ A / (2 (1-a(x/A)ᵇ) acos(x/A))
                */
                const arc_length = abs(min_length_clockwise);
                const a = 0.147;
                const b = 0.650;
                const x = glm.distance(source, target) / 2.0;
                const A = max(x, arc_length/2 );
                const xA = min(x/A, 1-epsilon);
                const r = A / (2.0 * (1.0 - a*pow(xA, b)) * acos(xA));
                return r;
            },
        }
    }

    /*
    `UserArcsAndSamplerArcs` is a namespace of pure functions that describe maps between `SamplerArc`s and `UserArc`s
    */
    function UserArcsAndSamplerArcs(arc_geometry) {
        const sign = Math.sign;
        const abs = Math.abs;
        const max = Math.max;
        return {
            'user_arc_to_sampler_arc': function(user_arc) {
                const radius = arc_geometry.radius(user_arc.source, user_arc.target, user_arc.min_length_clockwise);
                const origin = arc_geometry.origin(user_arc.source, user_arc.target, user_arc.min_length_clockwise, radius);
                const clockwise_sign = sign(user_arc.min_length_clockwise);
                const min_length = abs(user_arc.min_length_clockwise);
                const length = max(abs(user_arc.min_length_clockwise), glm.distance(user_arc.source, user_arc.target));
                const length_clockwise = clockwise_sign * length;
                return new SamplerArc(origin, user_arc.source.sub(origin), length_clockwise);
            },
        };
    }

    /*
    `SamplerArcProperties` is a namespace of pure functions describing properties for any point along a `SamplerArc`
    */
    function SamplerArcProperties(){
        const pi = Math.PI;
        const cos = Math.cos;
        const sin = Math.sin;
        const sign = Math.sign;
        return {
            normal: function (sampler_arc, distance) {
                const v = glm.normalize(sampler_arc.source_offset);
                const radius = glm.length(sampler_arc.source_offset);
                const theta = distance / radius;
                return glm.vec2(
                    v.x * cos(theta) - v.y * sin(theta),
                    v.x * sin(theta) + v.y * cos(theta),
                );
            },
            tangent: function (sampler_arc, distance) {
                const v = glm.normalize(sampler_arc.source_offset);
                const radius = glm.length(sampler_arc.source_offset);
                const theta = (distance / radius + pi/2.0* sign(sampler_arc.length_clockwise)) ;
                return glm.vec2(
                    v.x * cos(theta) - v.y * sin(theta),
                    v.x * sin(theta) + v.y * cos(theta),
                );
            },
            position: function (sampler_arc, distance){
                const v = sampler_arc.source_offset;
                const radius = glm.length(sampler_arc.source_offset);
                const theta = distance / radius;
                return glm.vec2(
                    v.x * cos(theta) - v.y * sin(theta),
                    v.x * sin(theta) + v.y * cos(theta),
                ).add(sampler_arc.origin);
            },
        }
    }

    /*
    `SamplerArcTruncation` is a namespace of pure functions that shift the start and end position of a `SamplerArc`
    */
    function SamplerArcResizing(sampler_arc_properties){
        const sign = Math.sign;
        return {
            resize: function (sampler_arc, source_offset, target_offset){
                const clockwise_sign = sign(sampler_arc.length_clockwise);
                source_offset *= clockwise_sign;
                target_offset *= clockwise_sign;
                return new SamplerArc(
                    sampler_arc.origin, 
                    sampler_arc_properties.position(sampler_arc, source_offset).sub(sampler_arc.origin), 
                    sampler_arc.length_clockwise - source_offset + target_offset
                );
            },
        }
    }

    /*
    `SamplerArcFrameShifting` is a namespace of pure functions that describe isomorphisms to and from a reference frame.
    `enter` accepts a position and reference frame, both expressed in terms of an implicit user defined reference frame,
    and returns a position that is defined in terms of the reference frame. `leave` is inverse to `enter`.
    */
    function SamplerArcFrameShifting(offset_frame_shifting, position_frame_shifting){
        return {
            'enter': (user_arrow, frame) => 
                new SamplerArc(
                    position_frame_shifting.enter(user_arrow.origin, frame),
                    offset_frame_shifting.enter(user_arrow.source_offset, frame),
                    user_arrow.length_clockwise / frame.unit_length,
                ),
            'leave': (user_arrow, frame) =>
                new SamplerArc(
                    position_frame_shifting.leave(user_arrow.origin, frame),
                    offset_frame_shifting.leave(user_arrow.source_offset, frame),
                    user_arrow.length_clockwise * frame.unit_length,
                ),
        };
    }

    /*
    `UserArcRendering` is a namespace of pure functions describing a small category mapping arcs to svg depictions
    */
    function UserArcRendering(arc_geometry){
        const pi = Math.PI;
        const sqrt = Math.sqrt;
        const max = Math.max;
        const abs = Math.abs;

        return {
            sampler_arc_to_svg_arc: function(arc){
                const min_length = abs(arc.min_length_clockwise);
                const length = max(min_length, glm.distance(arc.source, arc.target));
                const radius = arc_geometry.radius(arc.source, arc.target, arc.min_length_clockwise);
                return new SvgArc(arc.source, arc.target, 
                    radius, abs(arc.min_length_clockwise)/radius > pi, !arc.is_clockwise);
            },
            svg_arc_to_path: function(arc){
                return `M ${arc.source.x} ${arc.source.y} A ${arc.radius} ${arc.radius} 0 ${arc.is_large_arc?1:0} ${arc.is_clockwise?0:1} ${arc.target.x} ${arc.target.y}` ;
            },
        }
    }

    /*
    `SamplerArcRendering` is a namespace of pure functions describing a small category mapping arcs to svg depictions
    */
    function SamplerArcRendering(sampler_arc_properties){
        const pi = Math.PI;
        const sqrt = Math.sqrt;
        const max = Math.max;
        const abs = Math.abs;
        const cos = Math.cos;
        const sign = Math.sign;
        // A `SvgQuadraticBezier` is a representation for a quadratic Bezier that can be used by svg
        class SvgQuadraticBezier{
            constructor(points){
                this.points = points;
            }
        };

        return {
            sampler_arc_to_svg_bezier: function(sampler_arc, sample_point_count){
                const inscribed_radius = glm.length(sampler_arc.source_offset);
                const inscribed_circumference = 2.0*pi*inscribed_radius;
                const c = 1 / cos(pi * sampler_arc.length_clockwise / (inscribed_circumference*sample_point_count) );

                const inscribed_arc = sampler_arc;
                const circumscribed_arc = new SamplerArc(sampler_arc.origin, sampler_arc.source_offset.mul(c), sampler_arc.length_clockwise*c);

                const points = [ sampler_arc_properties.position(inscribed_arc, 0.0) ];
                for (let i = 1; i <= sample_point_count; i++) {
                    points.push(sampler_arc_properties.position(circumscribed_arc, circumscribed_arc.length_clockwise * (i-0.5)/sample_point_count));
                    points.push(sampler_arc_properties.position(inscribed_arc, inscribed_arc.length_clockwise * i/sample_point_count));
                }

                return new SvgQuadraticBezier(points);
            },
            svg_bezier_to_path: function(bezier){
                const points = bezier.points;
                const source = points[0];
                let output = `M ${source.x} ${source.y}`;
                for (let i = 1; i+1 < points.length; i+=2) {
                    const control = points[i];
                    const sample = points[i+1];
                    output += ` Q ${control.x} ${control.y} ${sample.x} ${sample.y}`;
                }
                return output;
            },
        }
    }

    /*
    `UserArcFrameShifting` is a namespace of pure functions that describe isomorphisms to and from a reference frame.
    `enter` accepts a position and reference frame, both expressed in terms of an implicit user defined reference frame,
    and returns a position that is defined in terms of the reference frame. `leave` is inverse to `enter`.
    */
    function UserArcFrameShifting(position_frame_shifting){
        const shifting = position_frame_shifting;
        return {
            'enter': (user_arrow, frame) => 
                new UserArc(
                    shifting.enter(user_arrow.source, frame),
                    shifting.enter(user_arrow.target, frame),
                    user_arrow.min_length_clockwise / frame.unit_length,
                ),
            'leave': (user_arrow, frame) =>
                new UserArc(
                    shifting.leave(user_arrow.source, frame),
                    shifting.leave(user_arrow.target, frame),
                    user_arrow.min_length_clockwise * frame.unit_length,
                ),
        };
    }


    /*
    `UserArcsAndStoredArcs` is a namespace of pure functions that describe maps between `UserArc`s and `StoredArc`s
    */
    function UserArcsAndStoredArcs(
        diagram_ids, 
        min_loop_chord_length, 
        max_loop_chord_length, 
        max_loop_snap_distance, 
        max_nonloop_snap_distance,
        cell_to_target_distance
    ) {
        const ids = diagram_ids;
        return {
            'user_arc_to_stored_arc': function(arc) {
                const source_cell = ids.cell_position_to_cell_id(arc.source);
                const target_cell = ids.cell_position_to_cell_id(arc.target);

                const is_loop = glm.distance(arc.source, arc.target) < max_loop_chord_length;
                const is_target_snapped = glm.distance(arc.target, target_cell) < (is_loop? max_loop_snap_distance : max_nonloop_snap_distance);
                const is_canceled = glm.distance(arc.target, source_cell) < min_loop_chord_length;
                const is_snapped = is_target_snapped && !is_canceled;

                const target = 
                      is_canceled?       source_cell
                    : is_target_snapped? target_cell
                    :                    arc.target;

                const target_offset_id = 
                      !is_snapped?  glm.vec2()
                    : is_loop?      ids.offset_to_offset_id(ids.cell_position_and_cell_id_to_offset(arc.target, target_cell)) 
                    :               glm.vec2();

                return new StoredArc(
                    source_cell, 
                    target, 
                    arc.min_length_clockwise, 
                    target_offset_id,
                    is_snapped
                );
            },
            'stored_arc_to_user_arc': function(arc){
                return new UserArc(
                    arc.source, 
                    arc.target_offset_id.mul(cell_to_target_distance).add(arc.target),
                    arc.min_length_clockwise
                );
            }
        };
    }

    /*
    `ScreenReferenceFrame` is a data structure that expresses a DiagramReferenceFrame 
    in a way that can be easily manipulated by the application while guaranteeing correctness 
    for all real valued attributes.
    */
    class ScreenReferenceFrameStore {
        constructor(topleft_cell_position, log2_cell_width){
            this.topleft_cell_position = topleft_cell_position;
            this.log2_cell_width = log2_cell_width;
        }
    }

    /*
    `ScreenReferenceFrameStorage` is a namespace of pure functions that describe the isomorphism 
    between a ScreenReferenceFrame and a DiagramReferenceFrame expressed in terms of "model space"
    where each cell is of unit length.
    */
    function ScreenReferenceFrameStorage(){
        const pow = Math.pow;
        const log2 = Math.log2;
        return {
            'pack': (frame) => new ScreenReferenceFrameStore(frame.origin, log2(1/frame.unit_length)),
            'unpack': (store) => new DiagramReferenceFrame(store.topleft_cell_position, 1/pow(2, store.log2_cell_width)),
        };
    }

    /*
    `ReferenceFrameShifting` is a namespace of pure functions that describe the isomorphism
    `enter` accepts two reference frames, both expressed in terms of an implicit user defined reference frame,
    and returns a new reference frame that is the first defined in terms of the second. `leave` is inverse to `enter`.
    */
    function ReferenceFrameShifting(position_frame_shifting){
        const shifting = position_frame_shifting;
        return {
            'enter': (frame1, frame2) => 
                new DiagramReferenceFrame(
                    shifting.enter(frame1.origin, frame2),
                    frame1.unit_length / frame2.unit_length,
                ),
            'leave': (frame1, frame2) =>
                new DiagramReferenceFrame(
                    shifting.leave(frame1.origin, frame2),
                    frame1.unit_length * frame2.unit_length,
                ),
        };
    }

    /*
    `DiagramArrow` is a data structure that represents every property of an arrow that can be depicted within the application
    */
    class DiagramArrow {
        constructor(
            arc, label, label_offset, 
            source_style_id, end_style_id, line_style_id
        ){
            this.arc = arc;
            this.label = label || "";
            this.label_offset = label_offset || 1;
            this.source_style_id = source_style_id;
            this.end_style_id = end_style_id;
            this.line_style_id = line_style_id;
        }
    }

    const DragState = {
        released: 'released',
        draw: 'draw',
        zoom: 'zoom',
        pan: 'pan',
    };

    /*
    `ApplicationState` is a data structure that contains all state within the application. 
    It guarantees that for any combination of real numbered attribute values there is a valid application state.
    */
    class ApplicationState {
        constructor(screen_frame_store, drag_state, arrows, edited_arrow){
            this.screen_frame_store = screen_frame_store;
            this.drag_state = drag_state;
            this.arrows = arrows;
            this.edited_arrow = edited_arrow;
        }
    }

    /*
    `ApplicationStateOperations` is a namespace of *conceptually* pure functions 
    that operate with no concept of what hardware is being used (e.g. mouse, touchscreen, etc.).
    All functions represent the transformation of state in reponse to controller events. 
    */
    function ApplicationStateOperations(
            screen_frame_storage,  
            offset_frame_shifting, 
            position_frame_shifting, 
            user_arcs_and_stored_arcs,
            default_min_length_clockwise
        ) {
        const sign = Math.sign;
        const abs = Math.abs;
        const max = Math.max;
        const storage = screen_frame_storage;
        const offset_shifting = offset_frame_shifting;
        const position_shifting = position_frame_shifting;
        return {
            zoom: function(state_in, screen_focus, log2_cell_width_change, state_out) {
                const screen_frame_store = state_in.screen_frame_store;
                const screen_frame = storage.unpack(screen_frame_store);
                const model_focus = position_shifting.leave(screen_focus, screen_frame);
                const topleft_zoom_frame_store = 
                    new ScreenReferenceFrameStore(
                        screen_frame_store.topleft_cell_position, 
                        screen_frame_store.log2_cell_width + log2_cell_width_change
                    );
                const topleft_zoom_frame = storage.unpack(topleft_zoom_frame_store);
                const screen_zoom_offset = position_shifting.enter(model_focus, topleft_zoom_frame).sub(screen_focus);
                const model_zoom_offset = offset_shifting.leave(screen_zoom_offset, screen_frame);
                state_out.screen_frame_store.topleft_cell_position = screen_frame_store.topleft_cell_position.add(model_zoom_offset);
                state_out.screen_frame_store.log2_cell_width = state_in.screen_frame_store.log2_cell_width + log2_cell_width_change;
                state_out.drag_state = DragState.zoom;
                state_out.arrows = [ ...state_in.arrows];
                state_out.edited_arrow = state_in.edited_arrow;
            },
            pan: function(state_in, screen_offset, state_out){
                const screen_frame = storage.unpack(state_in.screen_frame_store);
                const model_offset = offset_shifting.leave(screen_offset, screen_frame);
                state_out.screen_frame_store.topleft_cell_position = state_in.screen_frame_store.topleft_cell_position.sub(model_offset);
                state_out.screen_frame_store.log2_cell_width = state_in.screen_frame_store.log2_cell_width;
                state_out.drag_state = DragState.pan;
                state_out.arrows = [ ...state_in.arrows];
                state_out.edited_arrow = state_in.edited_arrow;
            },
            draw: function(state_in, screen_position, state_out){
                const screen_frame = storage.unpack(state_in.screen_frame_store);
                const model_position = position_shifting.leave(screen_position, screen_frame);

                const arc_view = new UserArc(
                    state_out.drag_state == DragState.draw? state_in.edited_arrow.arc.source : model_position, 
                    model_position,
                    state_out.drag_state == DragState.draw? state_in.edited_arrow.arc.min_length_clockwise : default_min_length_clockwise,
                );

                const diagram_arrow = new DiagramArrow(
                    user_arcs_and_stored_arcs.user_arc_to_stored_arc(arc_view),
                    state_in.edited_arrow.label,
                    state_in.edited_arrow.label_offset,
                    state_in.edited_arrow.source_style_id,
                    state_in.edited_arrow.end_style_id,
                    state_in.edited_arrow.line_style_id,
                );

                state_out.screen_frame_store = state_in.screen_frame_store;
                state_out.drag_state = DragState.draw;
                state_out.arrows = [ ...state_in.arrows];
                state_out.edited_arrow = diagram_arrow;
            },
            bend: function (state_in, min_length_clockwise_change, state_out) {
                const arrow_in = state_in.edited_arrow;
                const arc_in = arrow_in.arc;

                const chord_length = glm.distance(arc_in.source, arc_in.target);
                const arc_length1 = 0.7;
                const arc_length2 = max(arc_length1, chord_length);
                const min_arc_length = abs(arc_in.min_length_clockwise);
                const clockwise_sign = sign(arc_in.min_length_clockwise);
                const excess_in = clockwise_sign * max(min_arc_length - arc_length2, 0);
                const excess_out = excess_in + min_length_clockwise_change;
                const is_different_sign = sign(excess_in) * sign(excess_out) < 0;
                const min_length_clockwise_out = sign(excess_out) * (is_different_sign? arc_length1 : (abs(excess_out) + abs(arc_length2)));

                const diagram_arrow = new DiagramArrow(
                    new StoredArc(arc_in.source, arc_in.target, min_length_clockwise_out, arc_in.target_offset_id, arc_in.is_snapped),
                    arrow_in.label,
                    arrow_in.label_offset,
                    arrow_in.source_style_id,
                    arrow_in.end_style_id,
                    arrow_in.line_style_id,
                );

                state_out.screen_frame_store = state_in.screen_frame_store;
                state_out.drag_state = DragState.draw;
                state_out.arrows = [ ...state_in.arrows];
                state_out.edited_arrow = diagram_arrow;
            },
            release: function(state_in, state_out) {
                state_out.screen_frame_store = state_in.screen_frame_store;
                state_out.arrows = 
                    state_in.drag_state == DragState.draw && state_in.edited_arrow.arc.is_snapped ? 
                        [ ...state_in.arrows, state_in.edited_arrow] 
                    : 
                        [...state_in.arrows];
                state_out.drag_state = DragState.released;
                state_out.edited_arrow = new DiagramArrow(glm.vec2(), glm.vec2());
            },
            cancel: function(state_in, state_out) {
                state_out.screen_frame_store = state_in.screen_frame_store;
                state_out.drag_state = DragState.released;
                state_out.arrows = [ ...state_in.arrows];
                state_out.edited_arrow = new DiagramArrow(glm.vec2(), glm.vec2());
            },
            copy: function(state_in, state_out){
                state_out.screen_frame_store = state_in.screen_frame_store;
                state_out.drag_state = state_in.drag_state;
                state_out.arrows = [ ...state_in.arrows];
                state_out.edited_arrow = state_in.edited_arrow;
            },
            edit: function(state_in, arrow, state_out){
                state_out.screen_frame_store = state_in.screen_frame_store;
                state_out.drag_state = DragState.draw;
                state_out.arrows = [ ...state_in.arrows];
                const arrow_id = state_out.arrows.indexOf(arrow);
                if (arrow_id >= 0) {
                    state_out.arrows.splice(arrow_id, 1);
                }
                state_out.edited_arrow = arrow;
            }
        };
    }

    /*
    `ApplicationControls` is a namespace of *conceptually* pure functions that reflect how events map to actions.
    All functions represent the transformation of state in reponse to controller events. 
    It resembles an "Updater" within the "Model-View-Updater" pattern (A.K.A. "Elm" architecture)
    */
    function ApplicationControls(
        application_state_operations, 
        log2_cell_width_change_per_scroll,
        min_length_clockwise_change_per_scroll
    ){
        const operations = application_state_operations;
        const mouse_actions = {
            'pan':  (state_in, event, state_out) => operations.pan(state_in, glm.vec2(event.movementX, event.movementY), state_out),
            'draw': (state_in, event, state_out) => operations.draw(state_in, glm.vec2(event.clientX, event.clientY), state_out),
        };
        return {
            wheel: function(state_in, event, state_out){
                if (state_in.drag_state == DragState.draw) {
                    operations.bend(state_in, min_length_clockwise_change_per_scroll * event.deltaY, state_out);
                } else {
                    operations.zoom(state_in, glm.vec2(event.clientX, event.clientY), log2_cell_width_change_per_scroll * event.deltaY, state_out);
                }
            },
            mousedown: function(state_in, event, state_out){
                const state = [DragState.draw, DragState.pan, DragState.pan][event.button];
                if (state_in.drag_state == DragState.draw) { 
                    // cancel draw action
                    operations.cancel(state_in, state_out);
                } else if (state in mouse_actions){
                    mouse_actions[state](state_in, event, state_out); 
                }
                
            },
            mousemove: function(state_in, event, state_out){
                const state = state_in.drag_state;
                if (state in mouse_actions){
                    mouse_actions[state](state_in, event, state_out); 
                }
            },
            mouseup: function(state_in, event, state_out){
                operations.release(state_in, state_out);
            },
            touchsource: function(state_in, event, state_out){

            },
            touchend: function(state_in, event, state_out){

            },
            touchmove: function(state_in, event, state_out){

            },
        }
    }

    /*
    `EventQueueSideEffectWrapper` is a object oriented class that encapsulates all use of the javascript event system.
    This is done so that the rest of the application can be managed statelessly, using pure functions and categories.
    It practices RAII in that it binds events to a `domElement` upon construction and does not let go until dispose() is called.
    Events can be retrieved using `pollWithSideEffect()`, which returns a list of all events that occurred on 
    the diagram since the last invocation.
    */
    class EventQueueSideEffectWrapper{
        constructor(domElement){
            let queue = [];
            function enqueue( event ) { 
                queue.push(event);
            };
            function enqueuePrevent( event ) { 
                event.preventDefault(); 
                queue.push(event);
            };
            function enqueuePreventStop( event ) { 
                event.preventDefault(); 
                event.stopPropagation();
                queue.push(event);
            };

            domElement.addEventListener('contextmenu',    enqueuePrevent,     false);
            domElement.addEventListener('mousedown',      enqueuePrevent,     false);
            domElement.addEventListener('mousemove',      enqueuePrevent,     false);
            domElement.addEventListener('mouseup',        enqueue,            false);
            domElement.addEventListener('wheel',          enqueue,            false);
            domElement.addEventListener('touchsource',    enqueue,            false);
            domElement.addEventListener('touchmove',      enqueuePreventStop, false);
            domElement.addEventListener('touchend',       enqueue,            false);
            this.dispose = function(){
                domElement.removeEventListener('contextmenu',    enqueuePrevent,     false);
                domElement.removeEventListener('mousedown',      enqueuePrevent,     false);
                domElement.removeEventListener('mousemove',      enqueuePrevent,     false);
                domElement.removeEventListener('mouseup',        enqueue,            false);
                domElement.removeEventListener('wheel',          enqueue,            false);
                domElement.removeEventListener('touchsource',    enqueue,            false);
                domElement.removeEventListener('touchmove',      enqueuePreventStop, false);
                domElement.removeEventListener('touchend',       enqueue,            false);
            }
            this.pollWithSideEffect = function(){
                let events = queue;
                queue = [];
                return events;
            }
        }
    }

    const user_arcs_and_stored_arcs =
        UserArcsAndStoredArcs(
            DiagramIds(), 
            0.07, 0.5, 0.25, 0.3, // min loop, max loop, loop snap, nonloop snap
            0.01, // cell to target distance
        );
    const application_state_operations = 
        ApplicationStateOperations(
            ScreenReferenceFrameStorage(),
            OffsetFrameShifting(), 
            PositionFrameShifting(), 
            user_arcs_and_stored_arcs,
            0.7 // default_min_length_clockwise
        );

    const application_controls = 
        ApplicationControls(
            application_state_operations,
            -0.001, // log2_cell_width_change_per_scroll
            0.001 // min_length_change_per_scroll
        );

    const vue = new Vue({
        el: '#app',
        data:{
            state: 
                new ApplicationState(
                    new ScreenReferenceFrameStore(glm.vec2(), Math.log2(200)), 
                    DragState.released, 
                    [],
                    new DiagramArrow(glm.vec2(), glm.vec2()),
                ),
            queue: undefined,
            controls: application_controls,
            operations: application_state_operations,
            arrow_trimming_length: 0.07,
            user_arcs_and_stored_arcs: user_arcs_and_stored_arcs,
            user_arc_shifting: UserArcFrameShifting(PositionFrameShifting()),
            sampler_arc_shifting: SamplerArcFrameShifting(OffsetFrameShifting(), PositionFrameShifting()),
            sampler_arc_properties: SamplerArcProperties(),
            sampler_arc_resizing: SamplerArcResizing(SamplerArcProperties()),
            sampler_arc_rendering: SamplerArcRendering(SamplerArcProperties()),
            screen_frame_storage: ScreenReferenceFrameStorage(), 
            offset_shifting: OffsetFrameShifting(),
            position_shifting: PositionFrameShifting(),
            user_arcs_and_sampler_arcs: UserArcsAndSamplerArcs(ArcGeometry()),
            ids: DiagramIds(),
        },
        created: function() {
            // Register event manager in setTimeout to prevent vue from inapproprately touching event listeners
            setTimeout(() => {this.queue = new EventQueueSideEffectWrapper(document.getElementById('svg'));}, 1000/60);
            setInterval(() => {
                if (this.queue) {
                    let events = this.queue.pollWithSideEffect();
                    for(event of events){
                        if (event.type in this.controls){
                            this.controls[event.type](this.state, event, this.state);
                        }
                    }
                }
            }, 1000/60);
        },
        methods: {
            is_drawing: function(){
                return this.state.drag_state == DragState.draw;
            },
            transformation: function() {
                const screen_frame = this.screen_frame_storage.unpack(this.state.screen_frame_store);
                return `translate(${-screen_frame.origin.x} ${-screen_frame.origin.y})`;
            },
            cell_count: function() {
                return Math.ceil(Math.max(document.documentElement.clientWidth, document.documentElement.clientHeight) / Math.pow(2.0, this.state.screen_frame_store.log2_cell_width))+1;
            },
            cell_border_position: function(x, y) {
                const screen_frame = this.screen_frame_storage.unpack(this.state.screen_frame_store);
                const model_border_position = this.ids.border_id_to_cell_position( this.ids.cell_position_to_border_id(screen_frame.origin).add(glm.ivec2(x-1,y-1)) );
                return this.position_shifting.enter(model_border_position, screen_frame);
            },
            arrowsample: function(stored_arc, fraction) {
                const screen_frame = this.screen_frame_storage.unpack(this.state.screen_frame_store);
                const user_arc = this.user_arcs_and_stored_arcs.stored_arc_to_user_arc(stored_arc);
                const sampler_arc = this.user_arcs_and_sampler_arcs.user_arc_to_sampler_arc(user_arc);
                const resized_arc = this.sampler_arc_resizing.resize(sampler_arc, this.arrow_trimming_length, -this.arrow_trimming_length);
                const screen_arc = this.sampler_arc_shifting.enter(resized_arc, screen_frame);
                return this.sampler_arc_properties.position(screen_arc, fraction*screen_arc.length_clockwise);
            },
            arrowpath: function(stored_arc) {
                const screen_frame = this.screen_frame_storage.unpack(this.state.screen_frame_store);
                const user_arc = this.user_arcs_and_stored_arcs.stored_arc_to_user_arc(stored_arc);
                const sampler_arc = this.user_arcs_and_sampler_arcs.user_arc_to_sampler_arc(user_arc);
                const resized_arc = this.sampler_arc_resizing.resize(sampler_arc, this.arrow_trimming_length, -this.arrow_trimming_length);
                const screen_arc = this.sampler_arc_shifting.enter(resized_arc, screen_frame);

                const svg_bezier = this.sampler_arc_rendering.sampler_arc_to_svg_bezier(screen_arc, 10);
                const svg_path = this.sampler_arc_rendering.svg_bezier_to_path(svg_bezier);
                return svg_path;
            },
            arrowhead: function(stored_arc) {
                const screen_frame = this.screen_frame_storage.unpack(this.state.screen_frame_store);
                const user_arc = this.user_arcs_and_stored_arcs.stored_arc_to_user_arc(stored_arc);
                const sampler_arc = this.user_arcs_and_sampler_arcs.user_arc_to_sampler_arc(user_arc);
                const resized_arc = this.sampler_arc_resizing.resize(sampler_arc, this.arrow_trimming_length, -this.arrow_trimming_length);
                const arrowhead_basis_x = this.offset_shifting.enter(this.sampler_arc_properties.normal(resized_arc, resized_arc.length_clockwise), screen_frame);
                const arrowhead_basis_y = this.offset_shifting.enter(this.sampler_arc_properties.tangent(resized_arc, resized_arc.length_clockwise), screen_frame);
                const arrowhead_origin = this.position_shifting.enter(this.sampler_arc_properties.position(resized_arc, resized_arc.length_clockwise), screen_frame);

                const cell_points = [glm.vec2(-0.03,-0.03), glm.vec2(0,0), glm.vec2(0.03,-0.03)];
                const screen_points = cell_points.map(point => arrowhead_basis_x.mul(point.x).add(arrowhead_basis_y.mul(point.y)).add(arrowhead_origin));
                const path = 'M ' + screen_points.map(point => `${point.x} ${point.y}`).join(' L ');
                return path;
            },
            arrowclick: function(arrow, event) {
                event.preventDefault(); 
                event.stopPropagation();
                this.operations.edit(this.state, arrow, this.state);
            }
        }
    });
</script>
</body>
</html>